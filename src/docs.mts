/**
 * @file Transform documentation source files into files suitable for publishing and optionally copy
 *   the transformed files from the source directory to the directory used for the final, published
 *   documentation directory. The list of files transformed and copied to final documentation
 *   directory are logged to the console. If a file in the source directory has the same contents in
 *   the final directory, nothing is done (the final directory is up-to-date).
 * @example
 *   docs
 *   Run with no option flags
 *
 * @example
 *   docs --verify
 *   If the --verify option is used, it only _verifies_ that the final directory has been updated with the transformed files in the source directory.
 *   No files will be copied to the final documentation directory, but the list of files to be changed is shown on the console.
 *   If the final documentation directory does not have the transformed files from source directory
 *   - a message to the console will show that this command should be run without the --verify flag so that the final directory is updated, and
 *   - it will return a fail exit code (1)
 *
 * @example
 *   docs --git
 *   If the --git option is used, the command `git add docs` will be run after all transformations (and/or verifications) have completed successfully
 *   If not files were transformed, the git command is not run.
 */

import { remark } from 'remark';
import type { Code, Root } from 'mdast';
import { readFileSync, writeFileSync, mkdirSync, existsSync } from 'fs';
import { JSDOM } from 'jsdom';

// @ts-ignore
import flatmap from 'unist-util-flatmap';
import { globby } from 'globby';
import { join, dirname } from 'path';
import { exec } from 'child_process';
// @ts-ignore
import prettier from 'prettier';

const SOURCE_DOCS_DIR = 'src/docs/';
const FINAL_DOCS_DIR = 'docs/';
const AUTOGENERATED_TEXT =
  '# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT. Please edit the corresponding file in ${SOURCE_DOCS_DIR}.';

const LOGMSG_TRANSFORMED = 'transformed';
const LOGMSG_TO_BE_TRANSFORMED = 'to be transformed';
const LOGMSG_COPIED = ' ...and copied to ${FINAL_DOCS_DIR}';

const WARN_DOCSDIR_DOESNT_MATCH =
  "Changed files were transformed in `${SOURCE_DOCS_DIR}` but do not match the files in `${FINAL_DOCS_DIR}`. Please run `yarn docs:build` after making changes to '${SOURCE_DOCS_DIR}' to update the `${FINAL_DOCS_DIR}` directory with the transformed files.";

const verifyOnly = process.argv.includes('--verify');
const git = process.argv.includes('--git');

let filesWereTransformed = false;

/**
 * Given a source file name and path, return the documentation destination full path and file name
 * Create the destination path if it does not already exist. Possible Improvement: combine with
 * lint-staged to only copy files that have changed
 *
 * @param {string} file - Name of the file (including full path)
 * @returns {string} Name of the file with the path changed from the source directory to final
 *   documentation directory
 */
const prepareOutFile = (file: string): string => {
  const outFile = join(FINAL_DOCS_DIR, file.replace(SOURCE_DOCS_DIR, ''));
  mkdirSync(dirname(outFile), { recursive: true });
  return outFile;
};

/**
 * Verify that a file was changed and (potentially) write the new contents out to the file. Log a message to the console
 * If the file was not changed, do nothing. (No message is logged to the console.)
 *
 * @param file {string} name of the file that will be verified
 * @param content {string} new contents for the file
 */
const verifyAndCopy = (file: string, content?: string) => {
  const outFile = prepareOutFile(file);
  const existingBuffer = existsSync(outFile) ? readFileSync(outFile) : Buffer.from('#NEW FILE#');
  const newBuffer = content ? Buffer.from(content) : readFileSync(file);
  if (existingBuffer.equals(newBuffer)) {
    // Files are same, skip.
    return;
  }
  let changeMsg = 'changed';
  if (verifyOnly) {
    changeMsg = 'to be changed';
  }
  let logMsg = `  File ${changeMsg}: ${outFile}`;

  filesWereChanged = true;
  if (!verifyOnly) {
    writeFileSync(outFile, newBuffer);
    logMsg += ' ...and copied to /docs';
  }
  console.log(logMsg);
};

const readSyncedUTF8file = (file: string): string => {
  return readFileSync(file, 'utf8');
};

/**
 * Transform a markdown file and write the transformed file to the directory for published documentation
 * 1. Add a `mermaid-example` block before every `mermaid` or `mmd` block On the docsify site (one
 *    place where the documentation is published), this will show the code used for the mermaid diagram
 * 2. Add the text that says the file is automatically generated
 * 3. Use prettier to format the file Verify that the file has been changed and write out the changes
 *
 * @param file {string} name of the file that will be verified
 */
const transformMarkdown = (file: string) => {
  const doc = readSyncedUTF8file(file);
  const ast: Root = remark.parse(doc);
  const out = flatmap(ast, (c: Code) => {
    if (c.type !== 'code' || !c.lang?.startsWith('mermaid')) {
      return [c];
    }
    if (c.lang === 'mermaid' || c.lang === 'mmd') {
      c.lang = 'mermaid-example';
    }
    return [c, Object.assign({}, c, { lang: 'mermaid' })];
  });

  // Add the AUTOGENERATED_TEXT to the start of the file
  const transformed = `${AUTOGENERATED_TEXT}\n${remark.stringify(out)}`;

  verifyAndCopy(
    file,
    prettier.format(transformed, {
      parser: 'markdown',
      useTabs: false,
      tabWidth: 2,
      endOfLine: 'auto',
      printWidth: 100,
      singleQuote: true,
    })
  );
};

/**
 * Transform an HTML file and write the transformed file to the directory for published documentation
 * - Add the text that says the file is automatically generated Verify that the file has been changed
 *   and write out the changes
 *
 * @param filename {string} name of the HTML file to transform
 */
const transformHtml = (filename: string) => {
  /**
   * Insert the '...auto generated...' comment into an HTML file after the <html> element
   *
   * @param fileName {string} file name that should have the comment inserted
   * @returns {string} The contents of the file with the comment inserted
   */
  const insertAutoGeneratedComment = (fileName: string): string => {
    const fileContents = readSyncedUTF8file(fileName);
    const jsdom = new JSDOM(fileContents);
    const htmlDoc = jsdom.window.document;
    const autoGeneratedComment = jsdom.window.document.createComment(AUTOGENERATED_TEXT);

    const rootElement = htmlDoc.documentElement;
    rootElement.prepend(autoGeneratedComment);
    return jsdom.serialize();
  }

  const transformedHTML = insertAutoGeneratedComment(filename);
  verifyAndCopy(filename, transformedHTML);
};

/** Main method (entry point) */
(async () => {
  const sourceDirGlob = join(__dirname, SOURCE_DOCS_DIR, '**');
  const includeFilesStartingWithDot = true;

  console.log('Transforming markdown files...');
  const mdFiles = await globby([join(sourceDirGlob, '*.md')], { dot: includeFilesStartingWithDot });
  mdFiles.forEach(transformMarkdown);

  console.log('Transforming html files...');
  const htmlFiles = await globby([join(sourceDirGlob, '*.html')], {
    dot: includeFilesStartingWithDot,
  });
  htmlFiles.forEach(transformHtml);

  console.log('Transforming all other files...');
  const otherFiles = await globby([sourceDirGlob, '!**/*.md', '!**/*.html'], {
    dot: includeFilesStartingWithDot,
  });
  otherFiles.forEach((file) => {
    verifyAndCopy(file);
  });
  if (filesWereChanged) {
    if (verifyOnly) {
      console.log(WARN_DOCSDIR_DOESNT_MATCH);
      process.exit(1);
    }
    if (git) {
      console.log('Adding changes in ${FINAL_DOCS_DIR} folder to git');
      exec('git add docs');
    }
  }
})();
